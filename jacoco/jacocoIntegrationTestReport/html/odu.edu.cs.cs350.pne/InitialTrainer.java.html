<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InitialTrainer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Project-CS350</a> &gt; <a href="index.source.html" class="el_package">odu.edu.cs.cs350.pne</a> &gt; <span class="el_source">InitialTrainer.java</span></div><h1>InitialTrainer.java</h1><pre class="source lang-java linenums">package odu.edu.cs.cs350.pne;

import java.io.File;
import java.io.IOException;
import java.util.*;

import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.ConverterUtils.DataSink;


//-------------------------------------------------
//************ Data Flow (Temporary) **************
//-------------------------------------------------

public class InitialTrainer
{
<span class="nc" id="L20">    private final String[] categoryKeys = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;};</span>
    private String[] trainData;             
    private String[] vocabWords;            
<span class="nc" id="L23">    VocabCollection tempVocab = new VocabCollection();</span>

    public InitialTrainer()
<span class="nc" id="L26">    {</span>
<span class="nc" id="L27">        String[] tempData = {&quot;&quot;};   //category last</span>
        // String[] tempData = {&quot;0,1.3,3,0,A&quot;,
        //                      &quot;1.3,3,4,0,B&quot;,
        //                      &quot;1.5,0,0,2,C&quot;};   //TODO: supply sample data (categoryKey is first entry of each dataString)
        // String[] tempVocab = {&quot;computer&quot;, &quot;data&quot;, &quot;java&quot;, &quot;test&quot;};  //TODO: supply vocab words in order data supplies them
<span class="nc" id="L32">        String[] tempVocab = {&quot;&quot;};</span>
<span class="nc" id="L33">        trainData = tempData;</span>
<span class="nc" id="L34">        vocabWords = tempVocab;</span>
<span class="nc" id="L35">    }</span>

    //For Testing Purposes
    public InitialTrainer(String[] tempData, String[] tempVocab)
<span class="nc" id="L39">    {</span>
<span class="nc" id="L40">        trainData = tempData;</span>
<span class="nc" id="L41">        vocabWords = tempVocab;</span>
<span class="nc" id="L42">    }</span>
    
    public void run()
    {
<span class="nc" id="L46">        String arffPath = &quot;src/main/resources/train.arff&quot;;</span>
        //String arffPath = &quot;acmclass-data/train.arff&quot;;
<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (validARFFPresent(arffPath))</span>
<span class="nc" id="L49">            return;</span>

<span class="nc" id="L51">        String vocabPath = &quot;src/main/resources/vocabCollection.txt&quot;;</span>
        //String vocabPath = &quot;acmclass-data/vocabCollection.txt&quot;;
<span class="nc" id="L53">        File vocabFile = new File(vocabPath);</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">        if (vocabFile.exists()) //guard against prior runs</span>
<span class="nc" id="L55">            vocabFile.delete();</span>
<span class="nc" id="L56">        tempVocab.readInVocab(vocabPath);   //no path exists so it creates a new vocabFile</span>
<span class="nc" id="L57">        simulateVocabConstruction();</span>
<span class="nc" id="L58">        tempVocab.writeOutVocab(vocabPath); </span>
<span class="nc" id="L59">        Instances dTraining = dataExtractionWithData();</span>
<span class="nc" id="L60">        outputToARFF(dTraining, arffPath);</span>
<span class="nc" id="L61">    }</span>

    public boolean validARFFPresent(String arffPath)
    {
<span class="nc" id="L65">        File file = new File(arffPath);</span>
        try {
<span class="nc bnc" id="L67" title="All 2 branches missed.">            if (!file.exists())     //if file does not exist, create a file</span>
<span class="nc" id="L68">                file.createNewFile();</span>
            
<span class="nc bnc" id="L70" title="All 2 branches missed.">            if (file.length()==0)   //if file does not have content it is invalid</span>
<span class="nc" id="L71">                return false;</span>

<span class="nc" id="L73">            return true;            //else it is valid</span>
<span class="nc" id="L74">        } catch (IOException e) {</span>
<span class="nc" id="L75">            System.out.println(&quot;An error occurred.&quot;);</span>
<span class="nc" id="L76">            e.printStackTrace();</span>
<span class="nc" id="L77">            return false;</span>
        }
    }

    public void simulateVocabConstruction()
    {
<span class="nc" id="L83">        int numOfDocuments = trainData.length;</span>

        //initializes number of documents
<span class="nc bnc" id="L86" title="All 2 branches missed.">        for (int i=0; i&lt;numOfDocuments; i++)</span>
<span class="nc" id="L87">            tempVocab.increaseTotalDocs();</span>

        //Loop through document data
<span class="nc bnc" id="L90" title="All 2 branches missed.">        for (String data: trainData)</span>
        {
<span class="nc" id="L92">            String[] values = data.split(&quot;,&quot;);</span>

<span class="nc bnc" id="L94" title="All 2 branches missed.">            for (int i=0; i&lt;values.length-1; i++)</span>
            {
<span class="nc" id="L96">                double weight = Double.parseDouble(values[i]); //0 if not in doc, any number if in doc</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">                if (weight!=0)</span>
<span class="nc" id="L98">                    tempVocab.addWord(vocabWords[i]);</span>
            }
        }
<span class="nc" id="L101">    }</span>

    public Instances dataExtractionWithData()
    {
<span class="nc" id="L105">        ArrayList&lt;Attribute&gt; attrInfo = new ArrayList&lt;Attribute&gt;();</span>

<span class="nc bnc" id="L107" title="All 2 branches missed.">        for (String word: vocabWords)</span>
        {
<span class="nc" id="L109">            Attribute attr = new Attribute(word);</span>
<span class="nc" id="L110">            attrInfo.add(attr);</span>
        }

        //create and add category attribute
<span class="nc" id="L114">        ArrayList&lt;String&gt; categoryList = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L115">        categoryList.addAll(Arrays.asList(categoryKeys));</span>
<span class="nc" id="L116">        Attribute category = new Attribute(&quot;category&quot;, categoryList);</span>
<span class="nc" id="L117">        attrInfo.add(category);</span>

<span class="nc" id="L119">        final int numOfAttributes = attrInfo.size();</span>

<span class="nc" id="L121">        Instances training = new Instances(&quot;TrainingData&quot;, attrInfo, trainData.length);</span>
<span class="nc" id="L122">        training.setClass(category);</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">        for (String data: trainData)</span>
        {
<span class="nc" id="L126">            String[] values = data.split(&quot;,&quot;);</span>
<span class="nc" id="L127">            Instance instance = new DenseInstance(numOfAttributes);</span>
<span class="nc" id="L128">            instance.setDataset(training);</span>
            
<span class="nc" id="L130">            int i = 0;</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">            for (; i&lt;values.length-1; i++)</span>
<span class="nc" id="L132">                instance.setValue(i, Double.parseDouble(values[i]));</span>

<span class="nc" id="L134">            instance.setValue(i, values[i]);</span>
            
<span class="nc" id="L136">            training.add(instance);</span>
        }

<span class="nc" id="L139">        return training;</span>
    }

    public void outputToARFF(Instances training, String arffPath)
    {
        try
        {
<span class="nc" id="L146">            DataSink.write(arffPath, training);</span>
        }
<span class="nc" id="L148">        catch (Exception e)</span>
        {
<span class="nc" id="L150">            System.out.println(&quot;Failed to save to: &quot; + arffPath);</span>
<span class="nc" id="L151">            e.printStackTrace();</span>
<span class="nc" id="L152">        }</span>
<span class="nc" id="L153">    }</span>

    public VocabCollection getVocab()
    {
<span class="nc" id="L157">        return tempVocab;</span>
    }

    public String[] getTrainData()
    {
<span class="nc" id="L162">        return trainData;</span>
    }

    public String[] getVocabWords()
    {
<span class="nc" id="L167">        return vocabWords;</span>
    }
    
}

         //DO NOT DELETE PAST THIS POINT
//-------------------------------------------------
//************ FilePath Flow (Tabled) *************
//-------------------------------------------------

// public class InitialTrainer 
// {
//     private final String[] categoryKeys = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;};
//     private String[] trainFilePaths;     
//     private String[] fileCategories;         //these are categoryKeys
//     private List&lt;Document&gt; listOfDocuments = new ArrayList&lt;Document&gt;();
//     VocabCollection vocab;

//     public InitialTrainer()
//     {
//         String[] tempFilePaths = {&quot;&quot;};  //Tabled: put sample data files hardcoded in
//         String[] tempCategories = {&quot;&quot;}; //Tabled: put categories hardcoded in
//         trainFilePaths = tempFilePaths;
//         fileCategories = tempCategories;
//     }

//     //For Testing Purposes
//     public InitialTrainer(String[] tempFilePaths, String[] tempCategories)
//     {
//         trainFilePaths = tempFilePaths;
//         fileCategories = tempCategories;
//     }

//     public void run()
//     {
//         String arffPath = &quot;src/main/resources/train.arff&quot;;
//         if (validARFFPresent(arffPath))
//             return;

//         //FilePath Flow (With ArffGenerator)
//         constructInitialData();
//         ArffGenerator generator = new ArffGenerator(arffPath, vocab);
//         generator.generateInstances(listOfDocuments);
//         generator.outputToARFF();
//     }

//     public boolean validARFFPresent(String arffPath)
//     {
//         File file = new File(arffPath);
//         try {
//             if (!file.exists())     //if file does not exist, create a file
//                 file.createNewFile();
            
//             if (file.length()==0)   //if file does not have content it is invalid
//                 return false;

//             return true;            //else it is valid
//         } catch (IOException e) {
//             System.out.println(&quot;An error occurred.&quot;);
//             e.printStackTrace();
//             return false;
//         }
//     }

//     public void constructInitialData()
//     {
//         List&lt;TrainDocument&gt; trainDocs = new ArrayList&lt;TrainDocument&gt;();
//         String stopPath = &quot;src/main/resources/stopWords.txt&quot;;
//         String vocabPath = &quot;src/main/resources/vocabCollection.txt&quot;;
//         File vocabFile = new File(vocabPath);
//         if (vocabFile.exists()) //assure fresh vocab is created
//             vocabFile.delete();
//         TrainParser tParser = new TrainParser(new StopList(stopPath), vocabPath);   //no path exists so constructor creates a new vocabFile

//         int i = 0;
//         for (String path: trainFilePaths)
//         {
//             trainDocs.add(tParser.createDocument(path, fileCategories[i]));    //category supplied is a key
//             i++;
//         }
       
//         vocab = tParser.getVocabCollection();
//         vocab.calcInverseDocFrequency();

//         for (TrainDocument doc: trainDocs)
//         {
//             doc.calculateTermWeights(vocab);
//             listOfDocuments.add((Document)doc);
//         }
    
//         //tParser.writeOutVocabWrapper(vocabPath);
//         vocab.writeOutVocab(vocabPath);        
//     }

//     public String[] getFilePaths()
//     {
//         return trainFilePaths;
//     }

//     public String[] getFileCategories()
//     {
//         return fileCategories;
//     }

//     public VocabCollection getVocab()
//     {
//         return tempVocab;
//     }

//     public List&lt;Document&gt; getListOfDocs()
//     {
//         return listOfDocuments;
//     }
// }
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>